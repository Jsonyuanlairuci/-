锁机制
================================
# 一、表锁

### 一、排他锁（Exclusive）（写锁）
begin
select * from xxx where id=1 for update;
rollback;----锁释放
* 事务里进行修改就是排他锁

### 二、共享锁（Shared）（读锁）
begin
select * from xxx where id=1 lock in shared mode;
rollback;----锁释放
* 事务里进行查询就是共享锁

#### 备注
> 排他锁：主要使用在电商库存管理的时候，查询是需要加排他锁，修改库存后锁释放，防止其他线程读取导致数据错误。
* `多个共享锁是可以兼容的`
* `排他锁是互斥的`
* INnoDb的行锁是加载索引上的，是给索引加锁，而不是单纯的给行记录加锁。所以
过滤条件没有索引的话，使用的就是表锁，而不是行锁。所以使用行锁的时候，`需要针对where建立索引
才能保证行锁`。
> 说明：SS可以兼容，SX、XX之间是互斥的

### 三、间隙锁
隔离级别：串行读-》间隙锁 ----  next-key lock。
> 间隙锁，如果是范围查询，范围包含最后一条数据，会把最后一条后面也加锁。
 
> 意思是，如果范围包含最后一条，则无法进行插入操作。  

###  MVCC（多版本并发控制）
* innoDb提供了两种读取操作： 锁定读&&非锁定读
* MVCC快照读=》底层以来=》undo log（回滚日志）。

> undo log:回滚日志的主要作用:
* 1、事务发生错误时回滚rollback,
* 2、提供了MVCC的非锁定读（快照读）

# 二、表锁
* LOCK TABLE user READ;读锁锁表
* LOCK TABLE user WRITE;写锁锁表
> 事务
* commit/rollback:事务提交或者回滚
* UNLOCK TABLES:  本身自带提交事务，释放表锁

# 三、死锁
* `表锁`不会有死锁的问题
> 原因：多个线程在获取锁资源的时候，获取的顺序不同而导致斯多问题。
事务A->行锁1，事务B->行锁2：

* 事务A想获取行锁2，事务B想获取行锁1，导致两个事务互相等待。从而发生死锁的现象。
* 事务阻塞或者死锁，mysqld有是无阻塞的超时时间。标志事务处理失败。
* mysqld会检测到死锁问题，并且自动回滚。
### 解决死锁的问题
* 多个事务/线程 获取相同资源锁时，需要确保按照相同的顺序获取锁资源
